import matplotlib.pyplot as plt
import os
from matplotlib import animation 
from system import System, Pendulum, np, pd, pi, cos, sin, np, g

def make_phase_space(length_1=1, mass_1=1, length_2=1, mass_2=1, steps=1, time=100, angle_step_size=50, file_name=None, saved_data=None):
    '''
    Computes the phase space graph for the time it takes for either of the pendulum bobs to flip.

    Parameters
    ----------
    length_1 : int
        Rod length of the top pendulum bob.
    mass_1 : int
        Mass of the top pendulum bob.
    length_2 : int
        Rod length of the bottom pendulum bob.
    mass_2 : int
        Mass of the bottom pendulum bob.
    steps: int
        Number of steps in the double pendulum simulation.
    time : int
        Total time the double pendulum simulation runs for.
    angle_step_size : int
        Number of points to calculate for each angle e.g. a step size of 10 would correspond to 100 points on the graph (10 for each angle).
    file_name : str
        File name of the produced plot to save. If no name is specified, plot is not saved.
    saved_data : str
        File name of the phase space data to load and plot.
    
    Returns
    ----------
    None
    '''

    if saved_data:
        data = np.load(rf'{os.getcwd()}\{saved_data}.npz')
        angle_1, angle_2 = data['arr_0'], data['arr_1']
        time_to_flip = data['arr_2']

    else:
        initial_theta_1 = np.linspace(-pi, pi, angle_step_size)
        initial_theta_2 = np.linspace(-pi, pi, angle_step_size)
        angle_1, angle_2 = np.meshgrid(initial_theta_1, initial_theta_2)
        time_to_flip = np.zeros((angle_step_size, angle_step_size))
        counter = angle_step_size**2

        for x, theta_1 in enumerate(initial_theta_1):
            for y, theta_2 in enumerate(initial_theta_2):
                pendulum = System(length_1, mass_1, length_2, mass_2, theta_1, 0, theta_2, 0, steps, time)
                pendulum.run_simulation(method='Radau', is_phase=True)
                time_to_flip[x][y] = pendulum.flip_time 
                counter -= 1
                print(f'{counter} iterations remaining')
        
    units = np.sqrt(length_1/9.8)
    levels = [i*units for i in range(1000)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set(title='Phase space plot of the time it takes for the Double Pendulum to flip', ylabel='Initial displacement of top Pendulum (radians)', xlabel='Initial displacement of bottom Pendulum (radians)')
    cp = ax.contourf(angle_1, angle_2, time_to_flip, levels=levels, cmap='jet' ,extend='max')
    fig.colorbar(cp) 
    plt.show()

    if file_name:
        plt.savefig(rf'{os.getcwd()}\{file_name}.png')
        np.savez(rf'{os.getcwd()}\{file_name}', angle_1, angle_2, time_to_flip)

def make_plot_doublepend(pendulum_data, file_name=None):
    '''
    Takes in a Pandas Dataframe generated by the "make_data" method to produce plots of the position, velocity, acceleration and energy of the double pendulum.

    Parameters
    ----------
    pendulum_data : Pandas Dataframe
        A pandas dataframe from which the data to plot is extracted.
    file_name : str
        File name of the produced plot to save. If no name is specified, plot is not saved.
    
    Returns
    ----------
    None
    '''

    fig1 = plt.figure(constrained_layout=True)
    fig1.set_size_inches(32, 18)
    gs = fig1.add_gridspec(1, 3, hspace=0.5)
    position_ax = fig1.add_subplot(gs[0, 0])
    position_ax.set(title='Angular displacement of the \nDouble Pendulum over time.', ylabel='Angular displacement (radians)', xlabel='Time (s)')
    position_ax.plot(pendulum_data['Time'], pendulum_data['Angular position 1'], 'r-', label='Angular position 1')
    position_ax.plot(pendulum_data['Time'], pendulum_data['Angular position 2'], 'g-', label='Angular position 2')
    position_ax.legend(loc='upper left')

    velocity_ax = fig1.add_subplot(gs[0, 1])
    velocity_ax.set(title='Angular velocities of the \nDouble Pendulum over time.', ylabel='Angular velocity (radians/s)', xlabel='Time (s)')
    velocity_ax.plot(pendulum_data['Time'], pendulum_data['Angular velocity 1'], 'r-', label='Angular velocity 1')
    velocity_ax.plot(pendulum_data['Time'], pendulum_data['Angular velocity 2'], 'g-', label='Angular velocity 2')
    velocity_ax.legend(loc='upper left')

    acceleration_ax = fig1.add_subplot(gs[0, 2])
    acceleration_ax.set(title='Angular acceleration of the \nDouble Pendulum over time.', ylabel='Angular acceleration (radians/s^2)', xlabel='Time (s)')
    acceleration_ax.plot(pendulum_data['Time'], pendulum_data['Angular acceleration 1'], 'r-', label='Angular acceleration 1')
    acceleration_ax.plot(pendulum_data['Time'], pendulum_data['Angular acceleration 2'], 'g-', label='Angular acceleration 2')
    acceleration_ax.legend(loc='upper left')
    plt.show()

    fig2 = plt.figure()
    fig2.set_size_inches(32, 18)
    energy_ax = fig2.add_subplot(111)
    energy_ax.set(title='Energy of the Double Pendulum over time.', ylabel='Energy (J)', xlabel='Time (s)')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Kinetic energy'], 'b-', label='Kinetic energy')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Potential energy'], 'g-', label='Potential energy')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Total energy'], 'r-,', label='Total energy')
    plt.legend(loc='upper left')
    plt.show()

    if file_name:
        fig1.savefig(rf'{os.getcwd()}\{file_name}.png', bbox_inches='tight')
        fig2.savefig(rf'{os.getcwd()}\{file_name} energy.png', bbox_inches='tight')

def make_plot_singlepend(pendulum_data, file_name=None):
    '''
    Takes in a Pandas Dataframe generated by the "make_simple_pendulum" method to produce plots of the position, velocity, acceleration and energy of the simple pendulum.

    Parameters
    ----------
    pendulum_data : Pandas Dataframe
        A pandas dataframe from which the data to plot is extracted.
    file_name : str
        File name of the produced plot to save. If no name is specified, plot is not saved.
    
    Returns
    ----------
    None
    '''

    w = np.sqrt(g/1)
    A = pendulum_data['Angular position'].iloc[0]
    t = np.linspace(0, pendulum_data['Time'].iloc[-1], 10000)
    x = A*cos(w*t) # analytical solution for the simple pendulum position
    v = -A*w*sin(w*t) # analytical solution for the simple pendulum velocity
    a = -w**2*x # analytical solution for the simple pendulum acceleration

    fig1 = plt.figure(constrained_layout=True)
    fig1.set_size_inches(32, 18)
    gs = fig1.add_gridspec(1, 3)
    position_ax = fig1.add_subplot(gs[0, 0])
    position_ax.minorticks_on()
    position_ax.grid(which='major', linestyle='-', linewidth='0.5', color='black')
    position_ax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')
    position_ax.set(title='Angular displacements of the \nSimple Pendulum over time.', ylabel='Angular displacement (radians)', xlabel='Time (s)')
    position_ax.plot(pendulum_data['Time'], pendulum_data['Angular position'], 'r-', label='Angular position')
    position_ax.plot(t, x, 'b-', label='Expected angular position')
    position_ax.legend(loc='upper left')

    velocity_ax = fig1.add_subplot(gs[0, 1])
    velocity_ax.minorticks_on()
    velocity_ax.grid(which='major', linestyle='-', linewidth='0.5', color='black')
    velocity_ax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')
    velocity_ax.set(title='Angular velocity of the \nSimple Pendulum over time.', ylabel='Angular velocity (radians/s)', xlabel='Time (s)')
    velocity_ax.plot(pendulum_data['Time'], pendulum_data['Angular velocity'], 'r-', label='Angular velocity')
    velocity_ax.plot(t, v, 'b-', label='Expected angular velocity')
    velocity_ax.legend(loc='upper left')

    acceleration_ax = fig1.add_subplot(gs[0, 2])
    acceleration_ax.minorticks_on()
    acceleration_ax.grid(which='major', linestyle='-', linewidth='0.5', color='black')
    acceleration_ax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')
    acceleration_ax.set(title='Angular acceleration of \nthe Simple Pendulum over time.', ylabel='Angular acceleration (radians/s^2)', xlabel='Time (s)')
    acceleration_ax.plot(pendulum_data['Time'], pendulum_data['Angular acceleration'], 'r-', label='Angular position')
    acceleration_ax.plot(t, a, 'b-', label='Expected angular acceleration')
    acceleration_ax.legend(loc='upper left')
    plt.show()

    fig2 = plt.figure()
    fig2.set_size_inches(32, 18)
    energy_ax = fig2.add_subplot(111)
    energy_ax.set(title='Energy of the Simple Pendulum over time.', ylabel='Energy (J)', xlabel='Time (s)')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Kinetic energy'], 'b-', label='Kinetic Energy')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Potential energy'], 'g-', label='Potential Energy')
    energy_ax.plot(pendulum_data['Time'], pendulum_data['Total energy'], 'r-', label='Total Energy')
    energy_ax.legend(loc='upper left')
    plt.show()

    if file_name:
        fig1.savefig(rf'{os.getcwd()}\{file_name}.png', bbox_inches='tight')
        fig2.savefig(rf'{os.getcwd()}\{file_name} energy.png', bbox_inches='tight')

def make_animation(pendulum, pendulum_data, file_name=None):
    '''
    Generates a animation of the Double Pendulum.

    Parameters
    ----------
    pendulum : object
        An instance of the System class.
    pendulum_data : Pandas Dataframe
        A pandas dataframe from which the data to plot is extracted.
    file_name : str
        File name of the produced animation to save. If no name is specified, animation is not saved.
    
    Returns
    ----------
    None
    '''

    fig = plt.figure()
    total_length = pendulum.p1.L + pendulum.p2.L
    ax = plt.axes(xlim=(-total_length-0.5, total_length+0.5), ylim=(-total_length-0.5, total_length+0.5))
    ax.set(title='Animation of the Double Pendulum', ylabel='Angular displacement 1 (radians)', xlabel='Angular displacement 2 (radians)')
    line, = ax.plot([], [], 'o-')
    frames = pendulum.n

    def init():
        line.set_data([], [])
        return line,

    def animate(i):
        x1 = pendulum_data['x position 1'][i]
        y1 = pendulum_data['y position 1'][i]
        x2 = pendulum_data['x position 2'][i]
        y2 = pendulum_data['y position 2'][i]
        line.set_data([0, x1, x2], [0, y1, y2])
    
        return line,

    anim = animation.FuncAnimation(fig, animate, init_func=init, frames=frames, interval=25, blit=True)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

    if file_name:
        anim.save(rf'{os.getcwd()}\{file_name}.gif', writer='ffmpeg')
    
def make_plot_error(pend_data_1, pend_data_2, file_name=None):
    '''
    Takes in two Pandas Dataframes generated by the "make_data", that are produced using different numerical methods to plot a percentage error graph of the total energy to compare the methods.
    Parameters
    ----------
    pendu_data_1 : Pandas Dataframe
        A pandas dataframe from which the data to plot is extracted.
    pendu_data_2 : Pandas Dataframe
        A pandas dataframe from which the data to plot is extracted.
    file_name : str
        File name of the produced animation to save. If no name is specified, animation is not saved.
    
    Returns
    ----------
    None
    '''

    energy_1, energy_2 = pend_data_1['Total energy'], pend_data_2['Total energy']
    expected_E = energy_1.loc[0]
    error_1 = [abs(((obtained_E-expected_E)/expected_E))*100 for obtained_E in energy_1] # Uses formula for percentage error
    error_2 = [abs(((obtained_E-expected_E)/expected_E))*100 for obtained_E in energy_2]

    fig = plt.figure()
    fig.set_size_inches(32, 18)
    ax = fig.add_subplot(111)
    ax.set(title='Percentage error of total energy over time.', ylabel='Error (%)', xlabel='Time (s)')
    ax.plot(pend_data_1['Time'], error_1, 'b-', label='Explicit Runge-Kutta Error')
    ax.plot(pend_data_2['Time'], error_2, 'g-', label='Implicit Runge-Kutta Error')
    ax.legend(loc='upper left')
    plt.show()

    if file_name:
        fig.savefig(rf'{os.getcwd()}\{file_name}.png', bbox_inches='tight')

def save_data(pendulum_data, file_name):
    '''
    Saves the pandas dataframe.

    Parameters
    ----------
    pendulum_data : Pandas Dataframe
        Pandas dataframe to be saved.
    file_name : str
        File name of the data to save. 
    
    Returns 
    ----------
    None
    '''

    pendulum_data.to_pickle(rf'{os.getcwd()}\{file_name}')

def fetch_data(file_name):
    '''
    Reads in the saved pandas dataframe.

    Parameters
    ----------
    file_name : str
        File name of the data to read.

    Returns
    ----------
    Pandas Dataframe
        Returns the read in pandas dataframe. 
    '''

    return pd.read_pickle(rf'{os.getcwd()}\{file_name}')